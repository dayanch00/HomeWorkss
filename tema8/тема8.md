
Тема 8. Введение в ООП

Отчет по Теме #8 выполнил:

Мурадов Парахат

ПИЭ-23-1

| Задание | Лаб_раб | Сам_раб |
|---|---|---|
| Задание 1 |  |  |
| Задание 2 |  |  |
| Задание 3 |  |  |
| Задание 4 |  |  |
| Задание 5 |  |  |
| Задание 6 |  |  |
| Задание 7 |  |  |
| Задание 8 |  |  |
| Задание 9 |  |  |
| Задание 10 |  |  |


**Лабораторная работа №1**
___

**Создайте класс “Car” с атрибутами производитель и модель. Создайте объект этого класса. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями.**
```
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model

my_car = Car("BMW", "M5")
print(f"Производитель: {my_car.make}")
print(f"Модель: {my_car.model}")
```
Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema8/lab1.png)

Выводы.

1. class Car:: Объявляется класс Car - это чертеж для создания объектов "машина".
2. def __init__(self, make, model):: Это конструктор. Он вызывается, когда создается новый объект Car. self - ссылка на сам объект. make и model - параметры для производителя и модели.
3. self.make = make и self.model = model: Эти строки присваивают значения, переданные в конструктор, атрибутам (переменным внутри объекта) make и model каждого конкретного объекта Car.
4. my_car = Car("BMW", "M5"): Создается объект my_car класса Car, с производителем "BMW" и моделью "M5".
5. print(f"Производитель: {my_car.make}") и print(f"Модель: {my_car.model}"): Выводят на экран информацию о производителе и модели созданного автомобиля.

**Лабораторная работа №2**
___

**Дополните код из первого задания, добавив в него атрибуты и методы класса, заставьте машину “поехать”. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.**

```
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model

    def drive(self):
        print(f"Driving the {self.make} {self.model}")

my_car = Car("BMW", "M5")
my_car.drive()
```
Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema8/lab2.png)

Выводы.

def drive(self):: Это метод класса Car. Он описывает действие "езда" для объекта Car и печатает сообщение, используя атрибуты make и model этой машины.
my_car.drive(): Вызывается метод drive() для объекта my_car. Это заставляет объект my_car выполнить действие "езда", что приводит к выводу на экран сообщения: "Driving the BMW M5".

**Лабораторная работа №3**
___

**Создайте новый класс “ElectricCar” с методом “charge” и атрибутом емкость батареи. Реализуйте его наследование от класса, созданного в первом задании. Заставьте машину поехать, а потом заряжаться.
Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.**

```
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model

    def drive(self):
        print(f"Driving the {self.make} {self.model}")

my_car = Car("BMW", "M5")
my_car.drive()


class ElectricCar(Car):
    def __init__(self, make, model, battery_capacity):
        super().__init__(make, model)
        self.battery_capacity = battery_capacity

    def charge(self):
        print(f"Chrging the {self.make} {self.model} with {self.battery_capacity} kWh")


my_electric_car = ElectricCar("Tesla", "Model S", 75)
my_electric_car.drive()
my_electric_car.charge()
```

Результат.
![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema8/lab3.png)

Выводы.

1. Car: Базовый класс для машин, умеет "ехать" (drive).
2. ElectricCar: Класс наследует от Car (то есть, это тоже машина, умеет "ехать"), добавляет свойство battery_capacity (ёмкость батареи) и новое действие "заряжаться" (charge).
3. my_car: Обычная машина, едет.
4. my_electric_car: Электромобиль, который тоже может "ехать" (потому что наследует от Car) и "заряжаться" (свое собственное действие).

**Лабораторная работа №4**
___

**Реализуйте инкапсуляцию для класса, созданного в первом задании. Создайте защищенный атрибут производителя и приватный атрибут модели. Вызовите защищенный атрибут и заставьте машину поехать. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.**

```
class Car:
    def __init__(self, make, model):
        self._make = make
        self.__model = model

    def drive(self):
        print(f"Driving the {self._make} {self.__model}")

my_car = Car("BMW", "M5")
print(my_car._make)
my_car.drive()
```
Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema8/lab4.png)

Выводы.

1. Car: Класс для создания машин.
2. _make (одинарное подчеркивание): Атрибут производитель, который рекомендуется не трогать извне класса, но доступен напрямую.
3. __model (двойное подчеркивание): Атрибут модель, который Python скрывает (делает почти приватным), чтобы затруднить прямой доступ извне класса.
4. drive(): Метод, который внутри класса имеет доступ к обоим атрибутам (_make и __model).
5. print(my_car._make): Показывает, что к _make можно обратиться напрямую.
6. my_car.drive(): Вызывает метод drive, который успешно выводит оба атрибута.


**Лабораторная работа №5**
___

**Реализуйте полиморфизм создав основной (общий) класс “Shape”, а также еще два класса “Rectangle” и “Circle”. Внутри последних двух классов реализуйте методы для подсчета площади фигуры. После этого создайте массив с фигурами, поместите туда круг и прямоугольник, затем при помощи цикла выведите их площади. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.**

```
class Shape:
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height


class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3,14 * self.radius * self.radius
shapes = [
    Rectangle(5, 4),
    Circle(3),
    Rectangle(2, 6),
    Circle(2.5)
]


for shape in shapes:
    print(f"Площадь фигуры: {shape.area()}")  # Выводим площадь фигуры, используя метод area()
```

Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema8/lab5.png)

Выводы.
1. Shape: Базовый класс для всех фигур (общий шаблон).
2. Rectangle и Circle: Наследуют от Shape, каждый имеет свой собственный метод area() для расчета своей уникальной площади.
3. shapes: Список, содержащий объекты разных типов (Rectangle и Circle).
4. Цикл for: Проходит по этому списку, вызывая shape.area(). Python автоматически определяет, к какому типу фигуры относится shape, и вызывает соответствующий метод area().

**Самостоятельная работа №1**
___

**Самостоятельно создайте класс и его объект. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.**

```
class Dog:
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed

    def bark(self):
           print("Woof!")

    def display_info(self):
        print(f"Имя: {self.name}, Порода: {self.breed}")

my_dog = Dog("Бади", "Золотистый ретривер")

my_dog.display_info()
my_dog.bark()

```

Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema8/cam1.png)

Выводы.

1.  Класс Dog:  Описывает собак.  У каждой собаки есть имя (name) и порода (breed).
2.  Метод __init__:  Конструктор, инициализирует атрибуты name и breed при создании нового объекта Dog.
3.  Метод bark: Позволяет собаке лаять (выводит "Woof!" на экран).
4.  Метод display_info: Выводит информацию об имени и породе собаки.
5.  my_dog = Dog("Бади", "Золотистый ретривер"): Создает объект класса Dog с именем "Бади" и породой "Золотистый ретривер".
6.  my_dog.display_info() и my_dog.bark():  Вызывают методы display_info и bark для созданного объекта my_dog.

**Самостоятельная работа №2**
___
**Самостоятельно создайте атрибуты и методы для ранее созданного класса. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.**

```
class Dog:
    def __init__(self, name, breed, favorite_food): 
        self.name = name
        self.breed = breed
        self.favorite_food = favorite_food 
        self.mood = "счастлив"

    def bark(self):
        print("Гав-гав!")

    def wag_tail(self): 
        self.mood = "очень счастлив"
        print(f"{self.name} виляет хвостом и {self.mood}!")

my_dog = Dog("Луна", "Лабрадор", "курица")

print(f"Имя: {my_dog.name}, Порода: {my_dog.breed}")
print(f"Настроение Луны: {my_dog.mood}")
my_dog.wag_tail()
print(f"Теперь настроение Луны: {my_dog.mood}") 

```

Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema8/cam2.png)

Выводы.

1. class Dog:: Определен класс Dog (Собака).
2. __init__: Конструктор, теперь принимает favorite_food (любимая еда) и устанавливает mood (настроение) по умолчанию.
3. wag_tail(): Новый метод. Когда собака виляет хвостом, её mood меняется на "очень счастлив" и выводится сообщение.
4. my_dog = Dog(...): Создана собака Луна.


**Самостоятельная работа №3**
___

**Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом. Оно должно отличаться, от того, что указано в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.**

```
class Dog:
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed

    def bark(self):
        print(f"{self.name}: Гав-гав!")

class WorkingDog(Dog):
    def __init__(self, name, breed, job):
        super().__init__(name, breed)
        self.job = job
    def work(self):
           print(f"{self.name} ({self.breed}) выполняет свою работу: {self.job}.")
print("--- Обычный пес ---")
buddy = Dog("Бадди", "Мопс")
buddy.bark()

print("\n--- Рабочая собака ---")
koda = WorkingDog("Кода", "Колли", "пастух")
koda.bark()
koda.work()
```

Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema8/cam3.png)

Выводы.

1.  Dog: Базовый класс для собак, у каждой есть name и breed, и она умеет bark().
2.  WorkingDog(Dog): Класс "Рабочая собака" наследует от Dog. Это значит, что WorkingDog — это тоже Dog, но с дополнительными возможностями.
    •   super().__init__(...): Вызывает конструктор Dog, чтобы задать name и breed.
    •   Добавляет свой атрибут job (работа) и метод work().
3.  Демонстрация: buddy (обычная собака) может только bark(). koda (рабочая собака) может и bark() (унаследовано от Dog), и work() (свой собственный метод).


**Самостоятельная работа №4**
___

**Самостоятельно реализуйте инкапсуляцию, продолжая работать с ранее созданным классом. Она должна отличаться, от того, что указана в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.**

```
class Dog:
    def __init__(self, name, breed):
        self.name = name  #
        self._mood = "счастлив"
        self.__secret_trick = "прыжок"
    def bark(self):
        print(f"{self.name} говорит: Гав-гав! Он {self._mood}.")
    def teach_new_trick(self, new_trick):
        print(f"{self.name} учится новому секретному трюку...")
        self.__secret_trick = new_trick
        print(f"{self.name} теперь знает: {self.get_secret_trick()}")
    def get_secret_trick(self):
        return self.__secret_trick
my_dog = Dog("Бим", "Бигль")
print(f"Имя собаки : {my_dog.name}")
print(f"Настроение собаки: {my_dog._mood}")
my_dog._mood = "голоден"
print(f"Измененное настроение: {my_dog._mood}")
print(f"Секретный трюк: {my_dog.get_secret_trick()}")
my_dog.teach_new_trick("сальто")
print(f"Новый секретный трюк: {my_dog.get_secret_trick()}")
my_dog.bark()

```

Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema8/cam4.png)

Выводы.

1.  self.name: Публичный атрибут. Доступен и изменяем откуда угодно.
2.  self._mood: Защищенный атрибут (с _). Python не запрещает к нему прямой доступ, но это соглашение для программистов, что лучше использовать методы класса для работы с ним.
3.  self.__secret_trick: Приватный атрибут (с __). Python меняет его имя ("mangling"), чтобы прямой доступ извне класса (my_dog.__secret_trick) был невозможен, предотвращая случайные изменения.
4.  get_secret_trick() и teach_new_trick(): Эти методы - "интерфейс" для работы с __secret_trick, обеспечивающий контролируемый доступ к приватному состоянию объекта, что и есть суть инкапсуляции.



**Самостоятельная работа №5**
___
**Самостоятельно реализуйте полиморфизм. Он должен отличаться, от того, что указан в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.**

```
class Animal:
    def __init__(self, name):
        self.name = name
    def make_sound(self):
        pass
class Dog(Animal):
    def make_sound(self):
        print(f"{self.name} говорит: Гав!")
class Cat(Animal):
    def make_sound(self):
        print(f"{self.name} говорит: Мяу!")
animals = [
    Dog("Рекс"),
    Cat("Мурка"),
    Dog("Барон")
]
print("--- Животные издают звуки ---")
for animal in animals:
    animal.make_sound()

```

Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema8/cam5.png)

Выводы.

1.  Animal: Базовый класс, который определяет, что у каждого животного будет метод make_sound().
2.  Dog, Cat: Эти классы наследуют от Animal и переопределяют метод make_sound(), чтобы каждое животное издавало свой уникальный звук.
3.  animals: Список, содержащий объекты разных типов животных (Dog, Cat).
4.  for animal in animals: animal.make_sound(): В цикле мы вызываем один и тот же метод make_sound() для каждого объекта. Благодаря полиморфизму, Python автоматически определяет реальный тип объекта и вызывает соответствующую реализацию make_sound().
