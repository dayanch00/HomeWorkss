
Тема 4. Функции и модули

Отчет по Теме #4 выполнил:

Мурадов Парахат 

ПИЭ-23-1

| Задание | Лаб_раб | Сам_раб |
|---|---|---|
| Задание 1 |  |  |
| Задание 2 |  |  |
| Задание 3 |  |  |
| Задание 4 |  |  |
| Задание 5 |  |  |
| Задание 6 |  |  |
| Задание 7 |  |  |
| Задание 8 |  |  |
| Задание 9 |  |  |
| Задание 10 |  |  |


**Лабораторная работа №1**
___

**Напишите функцию, которая выполняет любые арифметические действия и выводит результат в консоль. Вызовите функцию используя “точку входа”.**
```
def main():
    print(2+2)
if __name__=='__main__':
    main() 
```
Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema4/lab1.png)

Выводы.
1. if __name__ == '__main__':: Проверяет, был ли файл запущен напрямую (как основная программа).
2. main(): Если да, то выполняет код внутри этого блока (в данном случае, вызывает функцию main).
   
**Лабораторная работа №2**
___

**Напишите функцию, которая выполняет любые арифметические действия, возвращает при помощи return значение в место, откуда вызывали функцию. Выведите результат в консоль. Вызовите функцию используя “точку входа”.**

```
def main():
  result = 2 + 2
  return result

if __name__ == '__main__':
  answer = main()
  print(answer)

```
Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema4/lab2.png)

Выводы.

1. def main()::  Определяет функцию main, которая выполняет сложение 2 + 2 и возвращает результат.
2. if __name__ == '__main__':: Это "точка входа".  Когда скрипт запускается, этот блок выполняет код.
3. answer = main():  Вызывает функцию main и сохраняет возвращенное значение в переменную answer.
4. print(answer):  Выводит значение переменной answer (то есть результат 2 + 2) в консоль.  Код извлекает результат арифметического действия из функции и выводит его.

**Лабораторная работа №3**
___

**Напишите функцию, в которую передаются два аргумента, над ними производится арифметическое действие, результат возвращается туда, откуда эту функцию вызывали. Выведите результат в консоль. Вызовите функцию в любом небольшом цикле.
На скриншоте ниже приведен пример программы, в которой аргумент функции	“x“превращается в параметр “one”, то же самое происходит с “y” и “two”**

```
def main(one, two):
  result = one + two
  return result
for i in range(5):
  x = 1
  y = 10
  answer = main(x, y)
  print(answer)

```

Результат.
![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema4/lab3.png)

Выводы.

1.  def main(one, two):: Создаем функцию main, которая принимает два значения (one и two).
2.  return one + two: Функция складывает эти два значения и возвращает их сумму.
3.  for i in range(5):: Этот цикл запускает код внутри себя 5 раз.
4.  x = 1, y = 10: В каждой итерации цикла задаем значения для x и y.
5.  answer = main(x, y): Вызываем функцию main, передавая ей значения x и y. Функция возвращает результат сложения, который сохраняется в answer.
6.  print(answer): Выводим answer (т.е. 11) в консоль на каждой итерации цикла.

**Лабораторная работа №4**
___

**Напишите функцию, на вход которой подается какое-то изначальное неизвестное количество аргументов, над которыми будет производится арифметические действия. Для выполнения задания необходимо использовать кортеж “*args”. На скриншоте ниже приведен пример такой программы с комментариями.
Для закрепления понимания работы с кортежами настоятельно рекомендуем поменять аргументы вызова функции, вручную посчитать результат, только потом запустить программу с новыми значениями и проверить себя, насколько вы поняли данный аспект программирования.**

```
def main(x, *args):
    one = x * 10
    two = sum(args)  # Складываем все числа из *args
    three = float(len(args))  # Количество чисел в *args
    print(f"one={one}\ntwo={two}\nthree={three}")
    return x + sum(args) / float(len(args))  # Арифметическое действие

if __name__ == '__main__':
    result = main(10, 0, 1, 2, -1, 0, -1, 1, 2)
    print(f"\nresult={result}")



```
Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema4/lab4.png)

Выводы.

1.  def main(x, *args):: Функция main принимает один обязательный аргумент x и произвольное количество дополнительных аргументов *args, которые собираются в кортеж.
2.  one = x * 10: Умножаем первый аргумент x на 10.
3.  two = sum(args): Суммируем все аргументы, переданные через *args.
4.  three = float(len(args)): Находим количество аргументов, переданных через *args, и преобразуем его в число с плавающей точкой.
5.  return x + sum(args) / float(len(args)): Выполняем арифметическое действие: x плюс среднее арифметическое аргументов из *args.
6.  if __name__ == '__main__':: Запускаем функцию main с первым аргументом 10 и произвольным набором чисел. Затем выводим полученный результат.

**Лабораторная работа №5**
___

**Напишите функцию, которая на вход получает кортеж “**kwargs” и при помощи цикла выводит значения, поступившие в функцию. На скриншоте ниже указаны два варианта вызова функции с “**kwargs” и два варианта работы с данными, поступившими в эту функцию. Комментарии в коде и теоретическая часть помогут вам разобраться в этом нелегком аспекте. Вызовите функцию используя “точку входа”.**

```
def main(**kwargs):
  for key, value in kwargs.items(): # kwargs.items() возвращает пары (ключ, значение)
    print(key, value)

  print()

  for key in kwargs: # Итерируем только по ключам словаря kwargs
    print(f"{key} = {kwargs[key]}") 
if __name__ == '__main__':
  main(x=[1, 2, 3], y=[3, 3, 0], z=[2, 3, 0], q=[3, 3, 0], w=[3, 3, 0])

  print("\n") 

  print("Второй вызов функции (распаковка словаря с помощью **):")
  data_for_main = {'x': [1, 2, 3], 'y': [3, 3, 0]}
  main(**data_for_main)

```

Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema4/lab5.png)

Выводы.

1.  def main(*kwargs):: Эта функция принимает *произвольное количество именованных аргументов*. *kwargs собирает все переданные имя=значение аргументы в *словарь* (например, { 'x': [1,2,3], 'y': [3,3,0] }).
2.  for key, value in kwargs.items():: Первый цикл перебирает пары (ключ, значение) из словаря kwargs и выводит их.
3.  for key in kwargs:: Второй цикл перебирает только ключи из словаря kwargs, а затем по каждому ключу (kwargs[key]) получает соответствующее значение для вывода.
4.  if __name__ == '__main__':: Это "точка входа" для запуска кода.

**Лабораторная работа №6**
___

**Напишите две функции. Первая – получает в виде параметра “**kwargs”. Вторая считает среднее арифметическое из значений первой функции. Вызовите первую функцию используя “точку входа” и минимум 4 аргумента.**

```
def mean(data):
    return sum(data) / float(len(data))

def main(**kwargs):
    for i, j in kwargs.items():
        print(f"{i}. Mean = {mean(j)}")

if __name__ == '__main__':
    main(x=[1, 2, 3], y=[3, 3, 0])

```

Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema4/lab6.png)


Выводы.
1.  mean(data):  Функция для вычисления среднего арифметического списка data.  Суммирует элементы (sum(data)) и делит на их количество (len(data)), преобразуя длину в float для получения десятичного результата.
2.  main(*kwargs): Функция, принимающая словарь именованных аргументов kwargs. Она итерируется по ключам (i) и значениям (j) этого словаря. Для каждого значения (которое предполагается списком) вычисляет среднее арифметическое, вызывая mean(j), и выводит на экран имя переменной (i) и ее среднее значение.
3.  if __name__ == '__main__':: Этот блок гарантирует, что код main(x=[1, 2, 3], y=[3, 3, 0]) будет выполнен только при запуске скрипта напрямую (а не при импорте его как модуля). Он вызывает функцию main с двумя именованными аргументами: x и y, каждый из которых представляет собой список чисел.

**Лабораторная работа №7**
___

**Создайте дополнительный файл .py. Напишите в нем любую функцию, которая будет что угодно выводить в консоль, но не вызывайте ее в нем. Откройте файл main.py, импортируйте в него функцию из нового файла и при помощи “точки входа” вызовите эту функцию**

```
def say_hello():
    print("Hello students!")


from labs import say_hello
if __name__=='__main__':
    say_hello()

```

Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema4/lab7.png)

Выводы.
for_import.py: Создан файл с функцией say_hello(), выводящей "Hello students!".
main.py: Функция say_hello() импортируется из for_import.py и вызывается внутри блока if __name__ == '__main__':, который является "точкой входа", то есть выполняется при запуске main.py. В результате при запуске main.py на экран выводится "Hello students!".

**Лабораторная работа №8**
___

**Напишите программу, которая будет выводить корень, синус, косинус полученного от пользователя числа.**

```
1.
import math
def main():
    value = int(input('Введите значение: '))
    print(math.sqrt(value)) 
    print(math.sin(value))  
    print(math.cos(value))  
if __name__ == '__main__':
    main()

2.
from math import sqrt, sin, cos
def main():
    value = int(input('Введите значение: '))
    print(sqrt(value)) 
    print(sin(value)) 
    print(cos(value)) 
if __name__ == '__main__':
    main()
3.
from math import *
def main():
    value = int(input('Введите значение: '))
    print(sqrt(value)) 
    print(sin(value)) 
    print(cos(value)) 
if __name__ == '__main__':
    main()


```

Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema4/lab8.png)

Выводы.
1.
Здесь мы полностью импортируем стандартный модуль math. После этого мы можем обращаться к его функциям (например, sqrt, sin, cos) через префикс math. (например, math.sqrt()). Пользователь вводит целое число, а программа выводит его квадратный корень, синус и косинус. if __name__ == '__main__': запускает функцию main() при прямом выполнении скрипта.
2.
В этом случае мы импортируем *только конкретные функции* (sqrt, sin, cos) из модуля math непосредственно в текущее пространство имен. Это означает, что теперь мы можем вызывать эти функции напрямую по их имени (например, sqrt()) без префикса math.
3.
Использование from math import * импортирует *все публичные функции и переменные* из модуля math непосредственно в текущее пространство имен. Как и при выборочном импорте, функции вызываются напрямую по имени (например, sqrt()) без префикса math.

**Лабораторная работа №9**
___

**Напишите программу, которая будет рассчитывать какой день недели будет через n-нное количество дней, которые укажет пользователь.**

```
from datetime import datetime as dt 
from datetime import timedelta as td

def main():
    print(f"Сегодня {dt.today().date()}.")
    print(f"День недели - {dt.today().isoweekday()}")

    n = int(input('Введите количество дней: '))

    today = dt.today()

    result = today + td(days=n)

    print(f"Через {n} дней будет {result.date()}.")
    print(f"День недели - {result.isoweekday()}")

if __name__ == '__main__':
    main()

```

Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema4/lab9.png)

Выводы.
1.  Импорты:
    •   from datetime import datetime as dt: Импортируем класс datetime из модуля datetime и даем ему короткий псевдоним dt. dt.today() возвращает текущую дату и время.
    •   from datetime import timedelta as td: Импортируем класс timedelta и даем ему псевдоним td. timedelta используется для представления промежутка времени (например, 5 дней).

2.  Текущая дата и день недели:
    •   dt.today().date(): Получает текущую дату (без времени).
    •   dt.today().isoweekday(): Получает текущий день недели в виде числа (1 = понедельник, 7 = воскресенье). Эти данные выводятся на экран.

3.  Ввод количества дней:
    •   n = int(input('Введите количество дней: ')): Пользователь вводит целое число, которое будет представлять количество дней для сдвига.

4.  Расчет будущей даты:
    •   today = dt.today(): Снова получаем текущую дату и время.
    •   result = today + td(days=n): К текущей дате today прибавляется n дней с помощью объекта timedelta. Результат сохраняется в переменной result.

5.  Вывод будущей даты и дня недели:
    •   result.date(): Из result извлекается только дата.
    •   result.isoweekday(): Из result извлекается день недели. Эти данные выводятся на экран.

6.  if __name__ == '__main__':: Гарантирует, что функция main() будет вызвана только при непосредственном запуске скрипта.

**Лабораторная работа №10**
___

**Напишите программу с использованием глобальных переменных, которая будет считать площадь треугольника или прямоугольника в зависимости от того, что выберет пользователь. Получение всей необходимой информации реализовать через input(), а подсчет площадей выполнить при помощи функций. Результатом программы будет число, равное площади, необходимой фигуры.**

```
global result

def rectangle():

    a = float(input("Ширина: "))
    b = float(input("Высота: "))
    global result
    result = a * b

def triangle():

    a = float(input("Основание: "))
    h = float(input("Высота: "))
    global result
    result = 0.5 * a * h

figure = input("1-прямоугольник, 2-треугольник: ")

if figure == '1':
    rectangle()
elif figure == '2':
    triangle()
print(f"Площадь: {result}")

```

Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema4/lab10.png)

Выводы.
1.  global result: В начале программы объявляется глобальная переменная result. Она доступна и может быть изменена из любой части кода.
2.  rectangle() и triangle(): Две функции для расчета площади.
    •   Они запрашивают у пользователя необходимые размеры (ширину/высоту или основание/высоту) с помощью input() и преобразуют их в числа с плавающей точкой (float()).
    •   Ключевое слово global result внутри этих функций необходимо для того, чтобы Python понял, что мы хотим изменить глобальную переменную result, а не создать новую локальную переменную с тем же именем.
    •   Рассчитанная площадь присваивается глобальной переменной result.
3.  Выбор пользователя: Программа запрашивает у пользователя, площадь какой фигуры он хочет посчитать (1 для прямоугольника, 2 для треугольника).
4.  Условный вызов: С помощью if/elif проверяется выбор пользователя, и вызывается соответствующая функция (rectangle() или triangle()).
5.  Вывод результата: После того как одна из функций отработала и обновила global result, программа выводит значение этой глобальной переменной.


**Самостоятельная работа №1**
___

**Дайте подробный комментарий для кода, написанного ниже. Комментарий нужен для каждой строчки кода, нужно описать что она делает. Не забудьте, что функции комментируются по-особенному**

```
from datetime import datetime            
from math import sqrt                    

def main(**kwargs):
    for key in kwargs.items():             
        result = sqrt(key[1][0] ** 2 + key[1][1] ** 2)  
        print(result)                  

if __name__ == '__main__':                
    start_time = datetime.now()           
    main(                                   
        one=[10, 3],                        
        two=[5, 4],
        three=[15, 13],
        four=[93, 53],
        five=[133, 15]
    )
    time_costs = datetime.now() - start_time  
    print(f"Время выполнения программы - {time_costs}") 

```

Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema4/cam1.png)

Выводы.

from datetime import datetime            # Импортируем класс datetime из модуля datetime для работы с датой и временем
from math import sqrt                     # Импортируем функцию sqrt из модуля math для вычисления квадратного корня

def main(**kwargs):
    """Функция main принимает произвольное количество именованных аргументов (kwargs),
    где каждому ключу соответствует последовательность из двух чисел.
    Для каждого такого значения вычисляет гипотенузу по теореме Пифагора и печатает результат.
    Параметры:
        **kwargs: именованные аргументы вида name=[a, b]
    Возвращаемое значение:
        None (функция только печатает результаты)
    """
    for key in kwargs.items():             # Итерируем по парам (ключ, значение) словаря kwargs; .items() возвращает последовательность кортежей
        # key — это кортеж вида (имя_аргумента, значение_аргумента)
        result = sqrt(key[1][0] ** 2 + key[1][1] ** 2)  # Берём вторую часть кортежа (key[1]) — это список/кортеж [a, b],
                                                        # затем key[1][0] и key[1][1] — первые два числа.
                                                        # Возводим их в квадрат, складываем и берём квадратный корень -> длина гипотенузы.
        print(result)                       # Печатаем вычисленный результат для текущей пары

if __name__ == '__main__':                # Блок, который выполняется только при запуске этого файла как основного скрипта
    start_time = datetime.now()            # Фиксируем текущее время начала выполнения программы
    main(                                   # Вызываем функцию main с пятью именованными аргументами,
        one=[10, 3],                        # каждый аргумент — список/кортеж из двух чисел
        two=[5, 4],
        three=[15, 13],
        four=[93, 53],
        five=[133, 15]
    )
    time_costs = datetime.now() - start_time  # Вычисляем разницу между текущим временем и временем старта -> продолжительность выполнения
    print(f"Время выполнения программы - {time_costs}")  # Печатаем время выполнения в читаемом формате (timedelta)

**Самостоятельная работа №2**
___
**Напишите программу, которая будет заменять игральную кость с 6 гранями. Если значение равно 5 или 6, то в консоль выводится «Вы победили», если значения 3 или 4, то вы рекурсивно должны вызвать эту же функцию, если значение 1 или 2, то в консоль выводится «Вы проиграли». При этом каждый вызов функции необходимо выводить в консоль значение “кубика”. Для выполнения задания необходимо использовать стандартную библиотеку random. Программу нужно написать, используя одну функцию и “точку входа”**

```
import random

def roll():
    value = random.randint(1, 6)
    print(f"Кубик: {value}")

    if value in (5, 6):
        print("Вы победили")
    elif value in (1, 2):
        print("Вы проиграли")
    else:
        print("Повторный бросок...")
        roll()

if __name__ == '__main__':
    roll()

```

Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema4/cam2.png)

Выводы.
- Функция roll() делает бросок (random.randint), печатает значение и в зависимости от него либо выводит результат (победа/поражение), либо при 3 или 4 рекурсивно вызывает себя для повторного броска.
- Блок if __name__ == '__main__': гарантирует, что бросок начнётся только при прямом запуске скрипта.

**Самостоятельная работа №3**
___

**Напишите программу, которая будет выводить текущее время, с точностью до секунд на протяжении 5 секунд. Программу нужно написать с использованием цикла. Подсказка: необходимо использовать модуль datetime и time, а также вам необходимо как-то “усыплять” программу на 1 секунду.**

```
from datetime import datetime as dt
import time

def show_time(seconds=5):


    for _ in range(seconds):
        print(dt.now().strftime('%H:%M:%S'))
        time.sleep(1)

if __name__ == '__main__':
    show_time(5)

```

Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema4/cam3.png)

Выводы.

- datetime.now().strftime('%H:%M:%S') выводит текущее время до секунд.
- time.sleep(1) приостанавливает выполнение на 1 секунду, поэтому вывод происходит каждую секунду.
- Цикл for гарантирует ровно 5 выводов.


**Самостоятельная работа №4**
___

**Напишите программу, которая считает среднее арифметическое от аргументов вызываемое функции, с условием того, что изначальное количество этих аргументов неизвестно. Программу необходимо реализовать используя одну функцию и “точку входа”.**

```
def average(*args):
    if not args:
        print("Нет аргументов для вычисления среднего.")
        return None
    result = sum(args) / len(args)
    print(f"Среднее арифметическое для {args} = {result}")
    return result

if __name__ == '__main__':
    average(1, 2, 3, 4)
    average(10, 20)
    average()

```

Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema4/cam4.png)

Выводы.

- *args позволяет функции принимать любое количество позиционных аргументов.
- sum(args)/len(args) вычисляет среднее; перед этим проверяем, что аргументы есть, чтобы избежать деления на ноль.
- Блок if __name__ == '__main__': служит «точкой входа» и показывает примеры вызова функции.


**Самостоятельная работа №5**
___
**Создайте два Python файла, в одном будет выполняться вычисление площади треугольника при помощи формулы Герона (необходимо реализовать через функцию), а во втором будет происходить взаимодействие с пользователем (получение всей необходимой информации и вывод результатов). Напишите эту программу и выведите в консоль полученную площадь.**

```
def triangle_area(a, b, c):

    a = float(a)
    b = float(b)
    c = float(c)

    if a <= 0 or b <= 0 or c <= 0:
        raise ValueError("Длины сторон должны быть положительными.")
    if a + b <= c or a + c <= b or b + c <= a:
        raise ValueError("Стороны не удовлетворяют неравенству треугольника.")

    s = (a + b + c) / 2.0
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    return area


from labs import triangle_area

def main():
    try:
        a = input("Введите длину стороны a: ")
        b = input("Введите длину стороны b: ")
        c = input("Введите длину стороны c: ")

        area = triangle_area(a, b, c)
    except ValueError as e:
        print("Ошибка:", e)
        return
    except Exception as e:
        print("Неожиданная ошибка:", e)
        return

    print(f"Площадь треугольника: {area:.6f}")

if __name__ == "__main__":
    main()



```

Результат.

![skriny](https://github.com/Parahat717/HomeWorks/blob/main/Pythons/tema4/cam5.png)

Выводы.

- Формула Герона: s = (a + b + c) / 2, площадь = sqrt(s (s-a) (s-b) (s-c)).
- В коде сначала проверяем, что стороны положительны и удовлетворяют неравенству треугольника, затем применяем формулу и возвращаем/выводим результат.
